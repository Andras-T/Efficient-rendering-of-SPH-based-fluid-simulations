//float sumX = 0.0f;
	//float sumY = 0.0f;
	//int xCount = 0;
	//int yCount = 0;
	//
	//float x = fragTexCoord.x;
	//float y = fragTexCoord.y;
	//
	//for (int i = -50; i < 50; i++) {
	//	float blurY = y + i * 0.001f;
	//	if (blurY >= 0.0f && blurY <= 1.0f) {
	//		float depth = texture(depthSampler, vec2(x, blurY)).r;
	//		sumY += depth;
	//		yCount++;
	//	}
	//
	//	float blurX = x + i * 0.001f;
	//	if (blurX >= 0.0f && blurX <= 1.0f) {
	//		float depthX = texture(depthSampler, vec2(blurX, y)).r;
	//		sumX += depthX;
	//		xCount += 1;
	//	}
	//}
	//
	//
	//float depthValue = 1.0f - (sumX / xCount + sumY / yCount);

	//float sum = 0.0f;
	//float depth = texture(depthSampler, fragTexCoord).r;
	//if (depth < 1.0f) {
	//	for (int i = -kernelSize / 2; i <= kernelSize / 2; i++) {
	//		//sum += texture(depthSampler, fragTexCoord + vec2(0.001f * float(i), 0.0)).r * weights[i + kernelSize / 2] * 0.5f;
	//		//sum += texture(depthSampler, fragTexCoord + vec2(0.0, 0.01f * float(i))).r * weights[i + kernelSize / 2] * 0.5f;
	//		sum += texture(depthSampler, fragTexCoord + vec2(0.001f * float(i), 0.0)).r * 0.5f * w[i + kernelSize / 2];
	//		sum += texture(depthSampler, fragTexCoord + vec2(0.0, 0.01f * float(i))).r * 0.5f * w[i + kernelSize / 2];
	//	}
	//} 
	//float depthValue = sum;



    //if (average < 0.998f) {
    //    float depthColor = (1.0f - average) * 50.0f;
    //    if (depthColor  > 0.1f)
    //        outColor = vec4(0.05f, 0.1f, 0.1f + depthColor, 1.0f);
    //    else
    //        outColor = vec4(0.5f, 0.7f, 0.7f, 1.0f);
    //} else {
    //    outColor = vec4(0.5f, 0.7f, 0.7f, 1.0f);
    //}


///////////////////////////

#version 450
#define PI 3.1415926538

vec3 velocity_;
vec3 position_;

struct Particle {
  vec4 position;
  vec3 velocity;
  float movable;
  vec3 acceleration;
  float density;
};

layout(binding = 0) uniform MVP {
  mat4 model;
  mat4 view;
  mat4 proj;
  vec3 cameraPos;
  float deltaTime;
}
mvp;

layout(std140, binding = 1) readonly buffer ParticleSSBOIn {
  Particle particlesIn[];
};

layout(std140, binding = 2) buffer ParticleSSBOOut { Particle particlesOut[]; };

layout(binding = 3) uniform Attributes {
  vec3 center;
  int numberOfParticles;
  float smootingLength;
  float mass;
  float stateConstant;
  float polytropicIndex;
  float damping;
  float gravity;
  float timeStep;
  int stop;
}
attributes;

layout(push_constant) uniform Constants { int stageIndex; }
constants;

layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

float W(float length) {
  return pow(1.0 / (attributes.smootingLength * sqrt(PI)), 3) *
         exp((-length * length) /
             (attributes.smootingLength * attributes.smootingLength));
}

vec3 gradW(vec3 position) {
  float r = length(position);
  return position * -2.0 *
         exp(-r * r / attributes.smootingLength * attributes.smootingLength) /
         ((attributes.smootingLength * attributes.smootingLength *
           attributes.smootingLength * attributes.smootingLength *
           attributes.smootingLength) *
          pow(PI, 1.5));
}

float getDensity(vec3 position) {
  float density = 0.0f;
  for (int i = 0; i < attributes.numberOfParticles; i++) {
    vec3 neighborPosition = particlesIn[i].position.xyz;
    float distance = length(position - neighborPosition);
    if (distance <= attributes.smootingLength)
      density += attributes.mass * W_quintic(distance);
  }
  return density;
}

float getPressure(float density) {
  return attributes.stateConstant * density * density * (1.0 + 1.0 / attributes.polytropicIndex);
         //pow(density, 1.0 + 1.0 / attributes.polytropicIndex);
}

vec3 getGravity() {
  vec4 transformedGravity4 =
      (inverse(mvp.model)) * vec4(0.0f, 0.0f, -attributes.gravity, 0.0f);
  return normalize(transformedGravity4.xyz) *
         length(vec3(0.0f, 0.0f, attributes.gravity));
}

vec3 getAcceleration(vec3 position, vec3 velocity, uint currentIndex) {
  vec3 acceleration = vec3(0.0f);
  for (uint i = 0; i < attributes.numberOfParticles; i++) {
    if (i == currentIndex) {
      continue; // Skip the current particle
    }
    vec3 neighborPosition = particlesIn[i].position.xyz;
    vec3 difference = position - neighborPosition;
    if (length(difference) <= attributes.smootingLength) {
      float density = particlesIn[i].density;
      float pressure = getPressure(density);
      vec3 gradW = quinticKernelGradient(difference);
      acceleration -=
          gradW * (attributes.mass * pressure / (density * density));
      acceleration -= acceleration * attributes.damping;
    }
  }

  return acceleration + getGravity();
}

void checkBoundary(float dist) {
  float slowingFactor = -0.015;
  if (position_.z < attributes.center.z - dist) {
    velocity_.z = slowingFactor * velocity_.z;
    position_.z = attributes.center.z - dist;
  } else if (position_.z > attributes.center.z + dist) {
    velocity_.z = slowingFactor * velocity_.z;
    position_.z = attributes.center.z + dist;
  }

  if (position_.y < attributes.center.y - dist) {
    velocity_.y = slowingFactor * velocity_.y;
    position_.y = attributes.center.y - dist;
  } else if (position_.y > attributes.center.y + dist) {
    velocity_.y = slowingFactor * velocity_.y;
    position_.y = attributes.center.y + dist;
  }

  if (position_.x < attributes.center.x - dist) {
    velocity_.x = slowingFactor * velocity_.x;
    position_.x = attributes.center.x - dist;
  } else if (position_.x > attributes.center.x + dist) {
    velocity_.x = slowingFactor * velocity_.x;
    position_.x = attributes.center.x + dist;
  }
}

void stageOne() {
  Particle currentParticle = particlesIn[gl_GlobalInvocationID.x];
  particlesOut[gl_GlobalInvocationID.x].density =
      getDensity(currentParticle.position.xyz);
}

void stageTwo() {
  Particle currentParticle = particlesIn[gl_GlobalInvocationID.x];
  //if (currentParticle.movable > 0.0f)
    particlesOut[gl_GlobalInvocationID.x].acceleration =
        getAcceleration(currentParticle.position.xyz, currentParticle.velocity,
                        gl_GlobalInvocationID.x);
}

void stageThree() {
  Particle currentParticle = particlesIn[gl_GlobalInvocationID.x];
  if (currentParticle.movable > 0.0f) {
    velocity_ = currentParticle.velocity +
                currentParticle.acceleration * attributes.timeStep * mvp.deltaTime / 2.0f;
    position_ =
        currentParticle.position.xyz + currentParticle.velocity * attributes.timeStep * mvp.deltaTime;
    checkBoundary(1.6f);
    particlesOut[gl_GlobalInvocationID.x].velocity = velocity_;
    particlesOut[gl_GlobalInvocationID.x].position = vec4(position_, 1.0f);
  }
}

void main() {
  if (constants.stageIndex == 1 && attributes.stop != 1) {
    stageOne();
  } else if (constants.stageIndex == 2 && attributes.stop != 1) {
    stageTwo();
  } else if (constants.stageIndex == 3 && attributes.stop != 1) {
    stageThree();
  } else {
    particlesOut[gl_GlobalInvocationID.x].velocity =
        particlesIn[gl_GlobalInvocationID.x].velocity;
    particlesOut[gl_GlobalInvocationID.x].position =
        particlesIn[gl_GlobalInvocationID.x].position;
  }
}