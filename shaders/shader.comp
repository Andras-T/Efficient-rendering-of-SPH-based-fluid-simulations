#version 450

#define PI 3.1415926538

uint currentIndex;
float smootingLength_;
float mass_;
vec3 transformedGravity_;
vec3 velocity_;
vec4 position_;

struct Particle {
  vec4 position;
  vec4 color;
  vec3 velocity;
  float movable;
  vec3 acceleration;
  float density;
};

layout(binding = 0) uniform MVP {
  mat4 model;
  mat4 view;
  mat4 proj;
  vec3 cameraPos;
  float deltaTime;
}
mvp;

layout(std140, binding = 1) readonly buffer ParticleSSBOIn {
  Particle particlesIn[];
};

layout(std140, binding = 2) buffer ParticleSSBOOut { Particle particlesOut[]; };

layout(binding = 3) uniform Attributes {
  vec3 center;
  int numberOfParticles;
  float smootingLength;
  float mass;
  float stateConstant;
  float polytropicIndex;
  float damping;
  float gravity;
  float timeStep;
  int stop;
}
attributes;

layout(push_constant) uniform Constants { int stageIndex; }
constants;

layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

float W(vec3 position) {
  float r = length(position);
  return pow(1.0 / (smootingLength_ * sqrt(PI)), 3) *
         exp(-r * r / (smootingLength_ * smootingLength_));
}

vec3 gradW(vec3 position) {
  float r = length(position);
  float n = -2.0 * exp(-r * r / (smootingLength_ * smootingLength_)) /
            pow(smootingLength_, 5) / pow(PI, 1.5);
  return n * position;
}

float getDensity(vec3 position) {
  float density = 0.0f;
  for (int i = 0; i < attributes.numberOfParticles; i++) {
    Particle neighbor = particlesIn[i];
    vec3 dist = position - neighbor.position.xyz;
    if (length(dist) <= smootingLength_) {
      density += mass_ * W(dist);
    }
  }
  return density;
}

vec3 getAcc(vec3 position, float rho, vec3 velocity) {
  vec3 acceleration = vec3(0.0, 0.0, 0.0);
  float polytropicIndex = attributes.polytropicIndex;
  float pressure =
      attributes.stateConstant * pow(rho, (1 + 1 / polytropicIndex));
  for (uint i = 0; i < attributes.numberOfParticles; i++) {
    Particle neighbor = particlesIn[i];
    vec3 distance = position - neighbor.position.xyz;
    float dist = length(distance);
    if (dist <= smootingLength_ && i != currentIndex) {
      vec3 dW = gradW(distance);
      float dP = pressure / (rho * rho) +
                 (attributes.stateConstant *
                  pow(neighbor.density, (1 + 1 / polytropicIndex))) /
                     (neighbor.density * neighbor.density);
      acceleration -= mass_ * dP * dW;
    }
  }
  acceleration -= (attributes.damping * 0.000002) * velocity;
  acceleration -= (attributes.damping * 0.000001) * acceleration;
  return acceleration + transformedGravity_ * (1 + attributes.damping / 1000);
}

void checkBoundaryBox(float dist) {
  float slowingFactor = -0.025;
  if (position_.z < attributes.center.z - dist) {
    velocity_.z = slowingFactor * velocity_.z;
    position_.z = attributes.center.z - dist;
  } else if (position_.z > attributes.center.z + dist) {
    velocity_.z = slowingFactor * velocity_.z;
    position_.z = attributes.center.z + dist;
  }

  if (position_.y < attributes.center.y - dist) {
    velocity_.y = slowingFactor * velocity_.y;
    position_.y = attributes.center.y - dist;
  } else if (position_.y > attributes.center.y + dist) {
    velocity_.y = slowingFactor * velocity_.y;
    position_.y = attributes.center.y + dist;
  }

  if (position_.x < attributes.center.x - dist) {
    velocity_.x = slowingFactor * velocity_.x;
    position_.x = attributes.center.x - dist;
  } else if (position_.x > attributes.center.x + dist) {
    velocity_.x = slowingFactor * velocity_.x;
    position_.x = attributes.center.x + dist;
  }
}

void stageOne() {
  Particle particleIn = particlesIn[currentIndex];
  particlesOut[currentIndex].density = getDensity(particleIn.position.xyz);
}

void stageTwo() {
  Particle particleIn = particlesIn[currentIndex];
  particlesOut[currentIndex].acceleration =
      getAcc(particleIn.position.xyz, particleIn.density, particleIn.velocity);
}

void stageThree() {
  Particle particleIn = particlesIn[currentIndex];
  if (particleIn.movable > 0.5) {
    velocity_ = particleIn.velocity +
                particleIn.acceleration * (mvp.deltaTime * attributes.timeStep);

    if (length(velocity_) > 0.004f)
      velocity_ = 0.1 * velocity_;
    if (length(velocity_) > 0.005f)
      velocity_ = 0.0 * velocity_;

    position_ = particleIn.position + vec4(particleIn.velocity, 0.0) *
                                          (mvp.deltaTime * attributes.timeStep);

    float maxDistance = 1.625f;
    checkBoundaryBox(maxDistance);

    if (isnan(position_.x) || isnan(position_.y) || isnan(position_.z) ||
        isnan(position_.w) || isnan(velocity_.x) || isnan(velocity_.y) ||
        isnan(velocity_.z) || length(velocity_) < 0.0000001f) {
      particlesOut[currentIndex].velocity =
          particlesIn[currentIndex].velocity * 0.025f;

      particlesOut[currentIndex].position =
          vec4(normalize(attributes.center.xyz -
                         particlesIn[currentIndex].position.xyz) *
                       (maxDistance * 0.0025) +
                   particlesIn[currentIndex].position.xyz,
               1);
      return;
    }
    particlesOut[currentIndex].velocity = velocity_;
    particlesOut[currentIndex].position = position_;
  }
}

void main() {
  if (attributes.stop == 0) {
    currentIndex = gl_GlobalInvocationID.x;
    smootingLength_ = clamp(attributes.smootingLength, 0.001f, 0.25f);
    mass_ = attributes.mass * 0.000000000000002f;

    vec4 transformedGravity4 =
        (inverse(mvp.model)) *
        vec4(0.0f, 0.0f, attributes.gravity * -0.0000000007f, 0.0f);
    transformedGravity_ =
        normalize(transformedGravity4.xyz) *
        length(vec3(0.0f, 0.0f, attributes.gravity * -0.0000000007f));

    if (constants.stageIndex == 1) {
      stageOne();
    } else if (constants.stageIndex == 2) {
      stageTwo();
    } else if (constants.stageIndex == 3) {
      stageThree();
    }
  }
}
